# Code reading

"Application Template", "Validation" or "System Performance" is generated by CubeMX following CubeMX components selection options.

## Application template

### Shape of input and output buffer (network.h)

```
#define AI_NETWORK_IN_NUM       (1)
#define AI_NETWORK_IN_1  \
  AI_BUFFER_OBJ_INIT(AI_BUFFER_FORMAT_FLOAT, 32, 32, 1, 1, NULL)
#define AI_NETWORK_IN_1_SIZE \
  (32 * 32 * 1)

#define AI_NETWORK_OUT_NUM      (1)
#define AI_NETWORK_OUT_1  \
  AI_BUFFER_OBJ_INIT(AI_BUFFER_FORMAT_FLOAT, 1, 1, 3, 1, NULL)
#define AI_NETWORK_OUT_1_SIZE \
  (1 * 1 * 3)
```

### Neural network (network.c)

My neural network is defined in the source code.

### Weights (network_data.c)

This is weights of the network.

```
ai_handle ai_network_data_weights_get(void)
{

  AI_ALIGNED(4)
  static const ai_u8 s_network_weights[ 23692 ] = {
    0x29, 0x4b, 0xe3, 0xbd, 0x1b, 0x90, 0x91, 0xbe, 0x98, 0xc3,
    0x54, 0xbe, 0xf3, 0x7a, 0xae, 0x3d, 0x59, 0x82, 0x6e, 0xbc,
    0xeb, 0x61, 0xa5, 0xbe, 0x69, 0x2d, 0xa9, 0xbd, 0xae, 0x03,
    0xac, 0xbe, 0x35, 0xc8, 0xb0, 0xbe, 0x96, 0xec, 0x05, 0xbe,
                         :
```

### Networks (app_x-cube-ai.c)

This is network entries definition as a constant.

```
static const ai_network_entry_t networks[AI_MNETWORK_NUMBER] = {
    {
        .name = (const char *)AI_NETWORK_MODEL_NAME,
        .config = AI_NETWORK_DATA_CONFIG,
        .ai_get_info = ai_network_get_info,
        .ai_create = ai_network_create,
        .ai_destroy = ai_network_destroy,
        .ai_get_error = ai_network_get_error,
        .ai_init = ai_network_init,
        .ai_run = ai_network_run,
        .ai_forward = ai_network_forward,
        .ai_data_weights_get_default = ai_network_data_weights_get,
        .params = { AI_NETWORK_DATA_WEIGHTS(0),
                AI_NETWORK_DATA_ACTIVATIONS(0)},
    },
};
```

### Basic APIs (app_x-cube-ai.c)

In my case, \*name is "network".

```
ai_error ai_mnetwork_create(const char *name, ai_handle* network,
        const ai_buffer* network_config);
        
ai_bool ai_mnetwork_init(ai_handle network, const ai_network_params* params);

ai_i32 ai_mnetwork_run(ai_handle network, const ai_buffer* input,
        ai_buffer* output);
```

### Buffer format (ai_platform.h)

This is a type definition of input and output buffers. As for width and size, I just follow the definitions in network.h.

```
/*!
 * @struct ai_buffer
 * @ingroup ai_platform
 * @brief Memory buffer storing data (optional) with a shape, size and type.
 * This datastruct is used also for network querying, where the data field may
 * may be NULL.
 */
typedef struct ai_buffer_ {
  ai_buffer_format        format;     /*!< buffer format */
  ai_u16                  n_batches;  /*!< number of batches in the buffer */
  ai_u16                  height;     /*!< buffer height dimension */
  ai_u16                  width;      /*!< buffer width dimension */
  ai_u32                  channels;   /*!< buffer number of channels */
  ai_handle               data;       /*!< pointer to buffer data */
} ai_buffer;
```

I used ["sklearn.preprocessing.scale"](https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.scale.html) to normalize the dataset for training CNN on Keras. Do I need to scale the data on STM32 as well?

```
/*!
 * @enum buffer formats enum list
 * @ingroup ai_platform
 *
 * List supported data buffer types.
 */
enum {
  AI_BUFFER_FORMAT_NONE     = 0x00,
  AI_BUFFER_FORMAT_FLOAT    = 0x01,
  AI_BUFFER_FORMAT_U8       = 0x10,
  AI_BUFFER_FORMAT_Q7       = 0x31, 
  AI_BUFFER_FORMAT_Q15      = 0x32,
};
```

## Validation

Refer to "aiValidation.c" that shows how to run the network.

### How to run the network

[Step 1: find a network]

In my network, set "idx" to 0 to find a network name.
```
 nn_name = ai_mnetwork_find(NULL, idx);
```
"nn_name" should be "network" in my case.

[Step 2: creat the network]
 
```
err = ai_mnetwork_create(nn_name, &net_exec_ctx[idx].network, NULL);
```

"&net_exec_ctx[idx].network" is a pointer to an empty "ai_handle" variable.

[Step 3: initalize the network]

```
err = ai_mnetwork_init(net_exec_ctx[idx].network, &params);
```

"params" as the second argument of the function call above is defined in the source code as follows:
```
static ai_u8 activations[AI_MNETWORK_DATA_ACTIVATIONS_SIZE];

const ai_network_params params = {
         AI_BUFFER_NULL(NULL),
         AI_BUFFER_NULL(activations) };
```

[Step 4: run the network]

```
static ai_float in_data[AI_MNETWORK_IN_1_SIZE];
static ai_float out_data[AI_MNETWORK_OUT_1_SIZE];

ai_buffer ai_input[1];
ai_buffer ai_output[1];

ai_input[0].n_batches  = 1;
ai_input[0].data = AI_HANDLE_PTR(in_data);
ai_output[0].n_batches = 1;
ai_output[0].data = AI_HANDLE_PTR(out_data);
```
    
```
batch = ai_mnetwork_run(ctx->network, &ai_input[0], &ai_output[0]);
```
